(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = global || self, global['react-dragable'] = factory(global.React));
}(this, (function (React) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var classnames = createCommonjsModule(function (module) {
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  /* global define */

  (function () {

  	var hasOwn = {}.hasOwnProperty;

  	function classNames () {
  		var classes = [];

  		for (var i = 0; i < arguments.length; i++) {
  			var arg = arguments[i];
  			if (!arg) continue;

  			var argType = typeof arg;

  			if (argType === 'string' || argType === 'number') {
  				classes.push(arg);
  			} else if (Array.isArray(arg) && arg.length) {
  				var inner = classNames.apply(null, arg);
  				if (inner) {
  					classes.push(inner);
  				}
  			} else if (argType === 'object') {
  				for (var key in arg) {
  					if (hasOwn.call(arg, key) && arg[key]) {
  						classes.push(key);
  					}
  				}
  			}
  		}

  		return classes.join(' ');
  	}

  	if ( module.exports) {
  		classNames.default = classNames;
  		module.exports = classNames;
  	} else {
  		window.classNames = classNames;
  	}
  }());
  });

  /**
   *  拖拽事件
   */
  var DRAG_EVENT_MAP = {
    DRAG_START: "mousedown",
    DRAG_MOVING: "mousemove",
    DRAG_STOP: "mouseup"
  };

  /**
   * 8个 archor : "nw", "n", "ne", "e", "se", "s", "sw", "w"
   */
  var ARCHOR = ["nw", "n", "ne", "e", "se", "s", "sw", "w"];
  /**
   * 操作类型
   *  - ROTATE = "rotate",
   *  - RESIZE = "resize",
   *  - MOVE = "move",
   *  - NONE = ""
   */

  var Actions;

  (function (Actions) {
    Actions["ROTATE"] = "rotate";
    Actions["RESIZE"] = "resize";
    Actions["MOVE"] = "move";
    Actions["NONE"] = "";
  })(Actions || (Actions = {}));
  /**
   * 初始化常量
   */


  var EMPTY_POINT = {
    x: 0,
    y: 0
  };
  var EMPTY_RECT = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    rotate: 0
  };
  var PRECISION = 1e-5;
  var symmetryPoint = function symmetryPoint(start, center) {
    var _map = ["x", "y"].map(function (k) {
      return start[k] + 2 * (center[k] - start[k]);
    }),
        _map2 = _slicedToArray(_map, 2),
        x = _map2[0],
        y = _map2[1];

    return {
      x: x,
      y: y
    };
  };
  /**
   * 近似相等
   * @param x
   * @param y
   * @param precision
   */

  var roughlyEqual = function roughlyEqual(x, y) {
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;
    return Math.abs(x - y) < precision;
  };
  /**
   * 获取鼠标位置 （使用pageX 受外界影响小）
   * @param e
   */


  var getMousePoint = function getMousePoint(e) {
    return {
      x: e.pageX,
      y: e.pageY
    };
  };
  /**
   * 计算一个矩形的中心点坐标
   * @param {*} rect
   */

  var rectCenter = function rectCenter(rect) {
    var x = rect.x,
        y = rect.y,
        width = rect.width,
        height = rect.height;
    return {
      x: x + width / 2,
      y: y + height / 2
    };
  };
  /**
   * 计算向量 point 的角度
   * @param {Point} point
   */

  var angleDegrees = function angleDegrees(point) {
    var x = point.x,
        y = point.y;
    return Math.atan2(y, x) * 180 / Math.PI;
  };
  /**
   * 页面坐标点 position 以 relative 点为原点
   * 顺时针旋转 angle 角度后得到的坐标点
   * @param {Point} position
   * @param {Point} relative
   * @param {Number} angle
   */

  var rotatePositionRelatively = function rotatePositionRelatively(position, relative, angle) {
    var shiftPosition = {
      x: position.x - relative.x,
      y: position.y - relative.y
    };
    var resultPosition = rotatePosition(shiftPosition, angle);
    return {
      x: resultPosition.x + relative.x,
      y: resultPosition.y + relative.y
    };
  };
  /**
   * 页面坐标点 position 以页面左上角为原点，顺时针旋转 angle 角度后得到的坐标点
   * @param {Point} position
   * @param {Number} angle
   */

  var rotatePosition = function rotatePosition(position, angle) {
    var radical = angle / 180 * Math.PI;
    var sinA = Math.sin(radical);
    var cosA = Math.cos(radical);
    var x = position.x,
        y = position.y;
    return {
      x: x * cosA - y * sinA,
      y: x * sinA + y * cosA
    };
  };
  /**
   * @param {Point} pa
   * @param {Point} pb
   * 获取坐标 pa 和 pb 的中间点坐标
   */

  var centerPoint = function centerPoint(pa, pb) {
    return {
      x: (pa.x + pb.x) / 2,
      y: (pa.y + pb.y) / 2
    };
  };
  /*
   * 原始矩形，倾斜角度为 0 deg
   * A----------------------B
   * |                      |
   * |                      |
   * |                      |
   * |                      |
   * |                      |
   * C----------------------D
   *
   */

  /**
   * 传入两点坐标，以及(线段 AC 的)倾斜角度
   * 返回唯一确定的矩形的位置
   * @param {Point} pa
   * @param {Point} pb
   * @param {Number} angel
   */

  var computeRectWithCrossPoints = function computeRectWithCrossPoints(pa, pb, angle) {
    var center = centerPoint(pa, pb);
    var rotatedPosition = rotatePositionRelatively(pb, center, -angle);
    var x = rotatedPosition.x,
        y = rotatedPosition.y;
    var width = Math.abs((x - center.x) * 2);
    var height = Math.abs((y - center.y) * 2);
    return {
      x: center.x - width / 2,
      y: center.y - height / 2,
      width: width,
      height: height,
      rotate: angle
    };
  };
  /**
   * 计算一条直线上（由 points 两点确定）离 point 点最近的点，即垂直交叉点
   * @param {Point[]} points
   * @param {Point} point
   */

  var squareCrossPoint = function squareCrossPoint(points, point) {
    var x = point.x,
        y = point.y;

    var _points = _slicedToArray(points, 2),
        p0 = _points[0],
        p1 = _points[1];

    if (roughlyEqual(p0.x, p1.x)) {
      return {
        x: p0.x,
        y: y
      };
    } else if (roughlyEqual(p0.y, p1.y)) {
      return {
        x: x,
        y: p0.y
      };
    }

    var baseSlope = lineSlope(p0, p1);
    var verticalSlope = -1 / baseSlope;
    var nextX = (baseSlope * p0.x + y - p0.y - verticalSlope * x) / (baseSlope - verticalSlope);
    var nextY = p0.y - baseSlope * (p0.x - nextX);
    return {
      x: nextX,
      y: nextY
    };
  };
  /**
   * 根据两点坐标，计算距离
   * @param {Point} p0
   * @param {Point} p1
   */

  var pointsDistance = function pointsDistance(p0, p1) {
    var x = p0.x - p1.x;
    var y = p0.y - p1.y;
    return Math.sqrt(x * x + y * y);
  };
  var EndPoints =
  /*#__PURE__*/
  function () {
    function EndPoints(rect) {
      _classCallCheck(this, EndPoints);

      this.rect = rect;
      this._lt = null;
      this._rt = null;
      this._rb = null;
      this._lb = null;
      this._ct = null;
      this._cb = null;
      this._rm = null;
      this._lm = null;
      this._center = null;
    }

    _createClass(EndPoints, [{
      key: "center",
      get: function get() {
        if (!this._center) {
          this._center = rectCenter(this.rect);
        }

        return this._center;
      }
    }, {
      key: "lt",
      get: function get() {
        if (!this._lt) {
          var _this$rect = this.rect,
              x = _this$rect.x,
              y = _this$rect.y,
              rotate = _this$rect.rotate;
          this._lt = rotatePositionRelatively({
            x: x,
            y: y
          }, this.center, rotate);
        }

        return this._lt;
      }
    }, {
      key: "rt",
      get: function get() {
        if (!this._rt) {
          var _this$rect2 = this.rect,
              x = _this$rect2.x,
              y = _this$rect2.y,
              width = _this$rect2.width,
              rotate = _this$rect2.rotate;
          this._rt = rotatePositionRelatively({
            x: x + width,
            y: y
          }, this.center, rotate);
        }

        return this._rt;
      }
    }, {
      key: "rb",
      get: function get() {
        if (!this._rb) {
          this._rb = symmetryPoint(this.lt, this.center);
        }

        return this._rb;
      }
    }, {
      key: "lb",
      get: function get() {
        if (!this._lb) {
          this._lb = symmetryPoint(this.rt, this.center);
        }

        return this._lb;
      }
    }, {
      key: "ct",
      get: function get() {
        if (!this._ct) {
          this._ct = centerPoint(this.lt, this.rt);
        }

        return this._ct;
      }
    }, {
      key: "cb",
      get: function get() {
        if (!this._cb) {
          this._cb = centerPoint(this.rb, this.lb);
        }

        return this._cb;
      }
    }, {
      key: "rm",
      get: function get() {
        if (!this._rm) {
          this._rm = centerPoint(this.rt, this.rb);
        }

        return this._rm;
      }
    }, {
      key: "lm",
      get: function get() {
        if (!this._lm) {
          this._lm = centerPoint(this.lt, this.lb);
        }

        return this._lm;
      }
    }]);

    return EndPoints;
  }();
  /* -------------------------------------------------------------------------- */

  /*                                    move                                    */

  /* -------------------------------------------------------------------------- */

  /**
   * 移动矩形，返回移动的矩形数据
   * @param {Point} mouseStart
   * @param {Point} mouseEnd
   * @param {Rect} rectStart
   */

  var moveRect = function moveRect(mouseStart, mouseEnd, rectStart) {
    var x = mouseEnd.x - mouseStart.x;
    var y = mouseEnd.y - mouseStart.y;
    return _objectSpread2({}, rectStart, {
      x: rectStart.x + x,
      y: rectStart.y + y
    });
  };
  /* -------------------------------------------------------------------------- */

  /*                                   rotate                                   */

  /* -------------------------------------------------------------------------- */

  /**
   * 根据两点坐标，计算其连线的斜率。注意，垂直时斜率是 Infinity
   * @param {Point} p0
   * @param {Point} p1
   */

  var lineSlope = function lineSlope(p0, p1) {
    return (p1.y - p0.y) / (p1.x - p0.x);
  };
  /**
   * 计算鼠标从 start 点拖到到 end 点时的旋转角度
   * @param {Point[]} pinnedPoints
   * @param {Point} start
   * @param {Point} end
   */

  var computeRotation = function computeRotation(center, start, end) {
    var shiftStart = {
      x: start.x - center.x,
      y: start.y - center.y
    };
    var shiftEnd = {
      x: end.x - center.x,
      y: end.y - center.y
    };
    var startDegrees = angleDegrees(shiftStart);
    var endDegrees = angleDegrees(shiftEnd);
    return endDegrees - startDegrees;
  };
  /**
   * 计算鼠标从 mouseStart 点开始按住旋转到 mouseEnd 后返回的矩形，值域为 [-180, 180]
   * @param {Point} mouseStart
   * @param {Point} mouseEnd
   * @param {Rect} rectStart
   */

  var rotateRect = function rotateRect(mouseStart, mouseEnd, rectStart) {
    var center = rectCenter(rectStart); // const shrotcutRotations = [-180, -135, -90, -45, 0, 45, 90, 135, 180]

    var offsetRotation = computeRotation(center, mouseStart, mouseEnd);
    var nextRotation = rectStart.rotate + offsetRotation;

    if (nextRotation >= 180) {
      nextRotation = nextRotation - 360;
    }

    if (nextRotation <= -180) {
      nextRotation = nextRotation + 360;
    }

    return _objectSpread2({}, rectStart, {
      rotate: nextRotation
    });
  };
  /* -------------------------------------------------------------------------- */

  /*                                   resize                                   */

  /* -------------------------------------------------------------------------- */

  /**
   * 根据一条边（pinnedPoints 两点确定），和对应的拖拽点（dragPoint），生成一个宽高比固定的矩形
   * @param {Point[]} pinnedPoints 拖拽固定边
   * @param {Point} dragPoint 拖拽点
   * @param {Number} rectRatio 原始矩形的宽高比
   * @param {"width" | "height"} activeExpand 拖拽的属性（width / height）
   */

  var computeRatioedRectWithPinnedLine = function computeRatioedRectWithPinnedLine(pinnedPoints, dragPoint, rectStart, activeExpand) {
    var _pinnedPoints = _slicedToArray(pinnedPoints, 2),
        p0 = _pinnedPoints[0],
        p1 = _pinnedPoints[1];

    var middle1 = centerPoint(p0, p1);
    var middle2 = dragPoint;
    var center = centerPoint(middle1, middle2);
    var distance = pointsDistance(middle1, middle2);
    var rectRatio = rectStart.width / rectStart.height;
    var width, height;

    if (activeExpand === "width") {
      width = distance;
      height = width / rectRatio;
    } else {
      height = distance;
      width = rectRatio * height;
    }

    return {
      x: center.x - width / 2,
      y: center.y - height / 2,
      width: width,
      height: height,
      rotate: rectStart.rotate
    };
  };
  /**
   * 根据一条线段（由 pinnedPoints 两点确定），拖拽点坐标（dragPoint），以及倾斜角度（angle）返回一个确定的矩形
   * @param {Point[]} pinnedPoints
   * @param {Point} dragPoint
   * @param {Number} angle
   */

  var computeRectWithPinnedLine = function computeRectWithPinnedLine(pinnedPoints, dragPoint, angle) {
    var _pinnedPoints$map = pinnedPoints.map(function (p) {
      return rotatePosition(p, -angle);
    }),
        _pinnedPoints$map2 = _slicedToArray(_pinnedPoints$map, 2),
        rotateP0 = _pinnedPoints$map2[0],
        rotateP1 = _pinnedPoints$map2[1];

    var rotateDrag = rotatePosition(dragPoint, -angle);
    var w, h, rotatedCenter;

    if (roughlyEqual(rotateP0.y, rotateP1.y)) {
      w = Math.abs(rotateP0.x - rotateP1.x);
      h = Math.abs(rotateDrag.y - rotateP0.y);
      rotatedCenter = {
        x: (rotateP0.x + rotateP1.x) / 2,
        y: (rotateP0.y + rotateDrag.y) / 2
      };
    } else if (roughlyEqual(rotateP0.x, rotateP1.x)) {
      h = Math.abs(rotateP0.y - rotateP1.y);
      w = Math.abs(rotateDrag.x - rotateP0.x);
      rotatedCenter = {
        x: (rotateP0.x + rotateDrag.x) / 2,
        y: (rotateP0.y + rotateP1.y) / 2
      };
    }

    var center = rotatePosition(rotatedCenter, angle);
    var x = center.x - (w || 0) / 2;
    var y = center.y - (h || 0) / 2;
    return {
      x: x,
      y: y,
      width: w,
      height: h,
      rotate: angle
    };
  };
  /**
   * resize 矩形，返回 resize 后的矩形数据
   * @param {Point} mouseStart
   * @param {Point} mouseEnd
   * @param {AdjustType} adjustType
   * @param {Rect} rectStart
   * @param {number} fixedRatio
   */

  var resizeRect = function resizeRect(mouseStart, mouseEnd, adjustType, rectStart, fixedRatio) {
    var e = new EndPoints(rectStart);
    var activeExpand = null;
    var acrossPoints = [];
    var fixedMouseEnd = mouseEnd;

    if (fixedRatio) {
      switch (adjustType) {
        case "nw":
        case "se":
          acrossPoints = [e.lt, e.rb];
          break;

        case "ne":
        case "sw":
          acrossPoints = [e.rt, e.lb];
          break;

        case "n":
        case "s":
          acrossPoints = [e.ct, e.cb];
          activeExpand = "height";
          break;

        case "w":
        case "e":
          acrossPoints = [e.lm, e.rm];
          activeExpand = "width";
          break;

        default:
          acrossPoints = [];
      }

      if (acrossPoints.length === 2) {
        fixedMouseEnd = squareCrossPoint(acrossPoints, mouseEnd);
      }
    }

    var pinnedPoints = [];

    switch (adjustType) {
      case "nw":
        pinnedPoints = [e.rb];
        break;

      case "ne":
        pinnedPoints = [e.lb];
        break;

      case "sw":
        pinnedPoints = [e.rt];
        break;

      case "se":
        pinnedPoints = [e.lt];
        break;

      case "s":
        pinnedPoints = [e.lt, e.rt];
        break;

      case "n":
        pinnedPoints = [e.lb, e.rb];
        break;

      case "w":
        pinnedPoints = [e.rt, e.rb];
        break;

      case "e":
        pinnedPoints = [e.lt, e.lb];
        break;

      default:
        pinnedPoints = [];
    }

    var _pinnedPoints2 = pinnedPoints,
        length = _pinnedPoints2.length;
    var result;

    if (length === 1) {
      result = computeRectWithCrossPoints(pinnedPoints[0], fixedMouseEnd, rectStart.rotate);
    } else if (length === 2) {
      if (fixedRatio) {
        result = computeRatioedRectWithPinnedLine(pinnedPoints, fixedMouseEnd, rectStart, activeExpand);
      } else {
        result = computeRectWithPinnedLine(pinnedPoints, fixedMouseEnd, rectStart.rotate);
      }
    }

    return result;
  };
  /**
   * 计算入口
   * @param {Position} mouseStart
   * @param {Position} mouseEnd
   * @param {AdjustType} adjustType: 'rotate'|'move'|'lt'|'rt'|'ct'|'lb'|'rb'|'cb'|'lm'|'rm'|null
   * @param {Rect} rectStart: { x: Number, y: Number, width: Number, height: Number, rotate: Number }
   * @param {Boolean} fixedRatio
   */

  var rotateResizeRect = (function (adjustType, mouseStart, mouseEnd, rectStart) {
    var fixedRatio = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    if (adjustType === "move") {
      return moveRect(mouseStart, mouseEnd, rectStart);
    }

    if (adjustType === "rotate") {
      return rotateRect(mouseStart, mouseEnd, rectStart);
    }

    return resizeRect(mouseStart, mouseEnd, adjustType, rectStart, fixedRatio);
  });

  /**
   *  绑定 dom 事件
   * @param el 事件绑定对象
   * @param eventKey 事件名称
   * @param listener 事件回调
   */
  var bindEvent = function bindEvent(el, eventKey, handler) {
    if (!el) {
      return;
    }

    if (el.attachEvent) {
      el.attachEvent("on" + eventKey, handler);
    } else if (el.addEventListener) {
      el.addEventListener(eventKey, handler, false);
    } else {
      el["on".concat(eventKey)] = handler;
    }
  };
  /**
   *  解绑 dom 事件
   * @param el 事件绑定对象
   * @param eventKey 事件名称
   * @param listener 事件回调
   */

  var unBindEvent = function unBindEvent(el, eventKey, handler) {
    if (!el) {
      return;
    }

    if (el.detachEvent) {
      el.detachEvent("on" + eventKey, handler);
    } else if (el.removeEventListener) {
      el.removeEventListener(eventKey, handler, false);
    } else {
      el["on".concat(eventKey)] = null;
    }
  };
  /**
   * 设置body 鼠标样式
   * @param cursor
   */

  var setBodyCursor = function setBodyCursor(cursor) {
    document.body.style.cursor = cursor;
  };

  var DRAG_MOVING = DRAG_EVENT_MAP.DRAG_MOVING,
      DRAG_STOP = DRAG_EVENT_MAP.DRAG_STOP;

  var RotateArrow = function RotateArrow(props) {
    var onMouseDown = props.onMouseDown;
    return React__default.createElement("svg", {
      className: "archor-rotate",
      onMouseDown: onMouseDown,
      viewBox: "0 0 1024 1024",
      width: "20",
      height: "20"
    }, React__default.createElement("path", {
      d: "M935.497143 659.017143a36.937143 36.937143 0 0 1-1.755429 18.505143 434.322286 434.322286 0 0 1-370.980571 337.773714C325.632 1045.650286 107.373714 876.251429 77.531429 637.293714a435.712 435.712 0 0 1 378.587428-487.131428c5.778286-1.243429 13.385143-1.901714 19.748572-1.974857-2.633143-24.137143-5.851429-46.518857-7.899429-66.267429-3.291429-25.526857-6.582857-44.617143-6.582857-50.980571-1.974857-7.021714-1.389714-15.36 3.657143-21.065143a21.796571 21.796571 0 0 1 31.305143-4.608l0.585142 1.243428 17.993143 16.530286 126.683429 98.962286 17.92 13.312 15.36 11.410285c5.12 3.803429 7.68 8.850286 8.996571 14.628572a20.260571 20.260571 0 0 1-4.388571 16.603428l-11.410286 15.36-13.312 17.92L555.885714 337.92l-14.555428 18.578286-1.243429 0.658285a23.625143 23.625143 0 0 1-31.890286 3.291429c-5.778286-5.12-9.654857-12.726857-8.411428-19.748571-1.316571-5.705143-3.291429-25.453714-6.582857-50.980572-2.633143-17.846857-5.266286-38.838857-7.899429-59.904-6.436571 0-13.385143 1.974857-19.748571 1.974857-193.828571 24.502857-332.726857 201.801143-308.297143 395.556572 24.502857 193.828571 201.801143 332.726857 395.556571 308.224a353.426286 353.426286 0 0 0 303.616-281.307429 40.082286 40.082286 0 0 1 34.377143-30.134857c22.235429-3.291429 43.373714 13.165714 44.763429 34.889143z"
    }));
  };

  var defaultProps = {};

  var Dragable =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Dragable, _Component);

    function Dragable() {
      var _this;

      _classCallCheck(this, Dragable);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Dragable).apply(this, arguments));
      _this.thisNode = null; // 便于计算的缓存变量

      _this.action = Actions.NONE;
      _this.mouseStart = EMPTY_POINT; // 变换开始前的鼠标位置

      _this.rectStart = EMPTY_RECT; // 变换开始前的rect

      _this.fixedRatio = false;
      _this.archor = "s";
      /**
       * 组件拖拽（进行中处理）
       *
       * @type {EventListener}
       * @memberof Dragable
       */

      _this.handleDragMove = function (e) {
        var onChange = _this.props.onChange;

        var _assertThisInitialize = _assertThisInitialized(_this),
            mouseStart = _assertThisInitialize.mouseStart,
            rectStart = _assertThisInitialize.rectStart,
            action = _assertThisInitialize.action,
            archor = _assertThisInitialize.archor,
            fixedRatio = _assertThisInitialize.fixedRatio;

        var mouseEnd = getMousePoint(e);
        onChange(rotateResizeRect(action === Actions.RESIZE ? archor : action, mouseStart, mouseEnd, rectStart, fixedRatio));
      };
      /**
       * 组件拖拽 (开始)
       *
       * @memberof Dragable
       */


      _this.handleDragStart = function (e, action) {
        e.stopPropagation();
        var event = e.nativeEvent;
        var rect = _this.props.rect;
        _this.mouseStart = getMousePoint(event);
        _this.rectStart = rect;
        _this.action = action;
        _this.fixedRatio = e.shiftKey; // 绑定 鼠标滑动与释放事件

        bindEvent(document, DRAG_MOVING, _this.handleDragMove);
        bindEvent(document, DRAG_STOP, _this.handleDragStop); // 设置 背景鼠标友好提示

        switch (action) {
          case Actions.MOVE:
            setBodyCursor("move");
            break;

          case Actions.ROTATE:
            setBodyCursor("pointer");
            break;

          case Actions.RESIZE:
            var cursor = event.target.style.cursor;
            setBodyCursor(cursor);
            _this.archor = cursor.replace(/-resize/, "");
            break;
        }
      };
      /**
       * 组件拖拽 (开始结束)
       *
       * @memberof Dragable
       */


      _this.handleDragStop = function () {
        //解绑拖拽事件
        unBindEvent(document, DRAG_MOVING, _this.handleDragMove);
        unBindEvent(document, DRAG_STOP, _this.handleDragStop); //重设

        setBodyCursor("auto");
      };

      return _this;
    }

    _createClass(Dragable, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        unBindEvent(document, DRAG_MOVING, this.handleDragMove);
        unBindEvent(document, DRAG_STOP, this.handleDragStop);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            rect = _this$props.rect,
            children = _this$props.children;
        return React__default.createElement("div", {
          onMouseDown: function onMouseDown(e) {
            return _this2.handleDragStart(e, Actions.MOVE);
          },
          className: classnames("dragable", {
            "dragable-active": true
          }),
          style: {
            left: rect.x,
            top: rect.y,
            width: rect.width,
            height: rect.height,
            transform: "rotate(".concat(rect.rotate, "deg)")
          }
        }, React__default.isValidElement(children) ? children : children(rect), ARCHOR.map(function (direct) {
          return React__default.createElement("i", {
            key: direct,
            className: classnames("archor", "archor-".concat(direct)),
            style: {
              cursor: "".concat(direct, "-resize")
            },
            onMouseDown: function onMouseDown(e) {
              return _this2.handleDragStart(e, Actions.RESIZE);
            }
          });
        }), React__default.createElement(RotateArrow, {
          onMouseDown: function onMouseDown(e) {
            return _this2.handleDragStart(e, Actions.ROTATE);
          }
        }));
      }
    }]);

    return Dragable;
  }(React.Component);

  Dragable.defaultProps = defaultProps;

  return Dragable;

})));
