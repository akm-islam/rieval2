"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.resizeRect = exports.computeRectWithPinnedLine = exports.computeRatioedRectWithPinnedLine = exports.rotateRect = exports.computeRotation = exports.lineDegrees = exports.lineSlope = exports.moveRect = exports.EndPoints = exports.pointsDistance = exports.squareCrossPoint = exports.computeRectWithCrossPoints = exports.centerPoint = exports.rotatePosition = exports.rotatePositionRelatively = exports.angleDegrees = exports.rectCenter = exports.getMousePoint = exports.symmetryPoint = exports.EMPTY_RECT = exports.EMPTY_POINT = exports.Actions = exports.ARCHOR = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * 8个 archor : "nw", "n", "ne", "e", "se", "s", "sw", "w"
 */
var ARCHOR = ["nw", "n", "ne", "e", "se", "s", "sw", "w"];
/**
 * 操作类型
 *  - ROTATE = "rotate",
 *  - RESIZE = "resize",
 *  - MOVE = "move",
 *  - NONE = ""
 */

exports.ARCHOR = ARCHOR;
var Actions;
exports.Actions = Actions;

(function (Actions) {
  Actions["ROTATE"] = "rotate";
  Actions["RESIZE"] = "resize";
  Actions["MOVE"] = "move";
  Actions["NONE"] = "";
})(Actions || (exports.Actions = Actions = {}));
/**
 * 初始化常量
 */


var EMPTY_POINT = {
  x: 0,
  y: 0
};
exports.EMPTY_POINT = EMPTY_POINT;
var EMPTY_RECT = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  rotate: 0
};
exports.EMPTY_RECT = EMPTY_RECT;
var PRECISION = 1e-5;

var symmetryPoint = function symmetryPoint(start, center) {
  var _map = ["x", "y"].map(function (k) {
    return start[k] + 2 * (center[k] - start[k]);
  }),
      _map2 = _slicedToArray(_map, 2),
      x = _map2[0],
      y = _map2[1];

  return {
    x: x,
    y: y
  };
};
/**
 * 近似相等
 * @param x
 * @param y
 * @param precision
 */


exports.symmetryPoint = symmetryPoint;

var roughlyEqual = function roughlyEqual(x, y) {
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;
  return Math.abs(x - y) < precision;
};
/**
 * 获取鼠标位置 （使用pageX 受外界影响小）
 * @param e
 */


var getMousePoint = function getMousePoint(e) {
  return {
    x: e.pageX,
    y: e.pageY
  };
};
/**
 * 计算一个矩形的中心点坐标
 * @param {*} rect
 */


exports.getMousePoint = getMousePoint;

var rectCenter = function rectCenter(rect) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height;
  return {
    x: x + width / 2,
    y: y + height / 2
  };
};
/**
 * 计算向量 point 的角度
 * @param {Point} point
 */


exports.rectCenter = rectCenter;

var angleDegrees = function angleDegrees(point) {
  var x = point.x,
      y = point.y;
  return Math.atan2(y, x) * 180 / Math.PI;
};
/**
 * 页面坐标点 position 以 relative 点为原点
 * 顺时针旋转 angle 角度后得到的坐标点
 * @param {Point} position
 * @param {Point} relative
 * @param {Number} angle
 */


exports.angleDegrees = angleDegrees;

var rotatePositionRelatively = function rotatePositionRelatively(position, relative, angle) {
  var shiftPosition = {
    x: position.x - relative.x,
    y: position.y - relative.y
  };
  var resultPosition = rotatePosition(shiftPosition, angle);
  return {
    x: resultPosition.x + relative.x,
    y: resultPosition.y + relative.y
  };
};
/**
 * 页面坐标点 position 以页面左上角为原点，顺时针旋转 angle 角度后得到的坐标点
 * @param {Point} position
 * @param {Number} angle
 */


exports.rotatePositionRelatively = rotatePositionRelatively;

var rotatePosition = function rotatePosition(position, angle) {
  var radical = angle / 180 * Math.PI;
  var sinA = Math.sin(radical);
  var cosA = Math.cos(radical);
  var x = position.x,
      y = position.y;
  return {
    x: x * cosA - y * sinA,
    y: x * sinA + y * cosA
  };
};
/**
 * @param {Point} pa
 * @param {Point} pb
 * 获取坐标 pa 和 pb 的中间点坐标
 */


exports.rotatePosition = rotatePosition;

var centerPoint = function centerPoint(pa, pb) {
  return {
    x: (pa.x + pb.x) / 2,
    y: (pa.y + pb.y) / 2
  };
};
/*
 * 原始矩形，倾斜角度为 0 deg
 * A----------------------B
 * |                      |
 * |                      |
 * |                      |
 * |                      |
 * |                      |
 * C----------------------D
 *
 */

/**
 * 传入两点坐标，以及(线段 AC 的)倾斜角度
 * 返回唯一确定的矩形的位置
 * @param {Point} pa
 * @param {Point} pb
 * @param {Number} angel
 */


exports.centerPoint = centerPoint;

var computeRectWithCrossPoints = function computeRectWithCrossPoints(pa, pb, angle) {
  var center = centerPoint(pa, pb);
  var rotatedPosition = rotatePositionRelatively(pb, center, -angle);
  var x = rotatedPosition.x,
      y = rotatedPosition.y;
  var width = Math.abs((x - center.x) * 2);
  var height = Math.abs((y - center.y) * 2);
  return {
    x: center.x - width / 2,
    y: center.y - height / 2,
    width: width,
    height: height,
    rotate: angle
  };
};
/**
 * 计算一条直线上（由 points 两点确定）离 point 点最近的点，即垂直交叉点
 * @param {Point[]} points
 * @param {Point} point
 */


exports.computeRectWithCrossPoints = computeRectWithCrossPoints;

var squareCrossPoint = function squareCrossPoint(points, point) {
  var x = point.x,
      y = point.y;

  var _points = _slicedToArray(points, 2),
      p0 = _points[0],
      p1 = _points[1];

  if (roughlyEqual(p0.x, p1.x)) {
    return {
      x: p0.x,
      y: y
    };
  } else if (roughlyEqual(p0.y, p1.y)) {
    return {
      x: x,
      y: p0.y
    };
  }

  var baseSlope = lineSlope(p0, p1);
  var verticalSlope = -1 / baseSlope;
  var nextX = (baseSlope * p0.x + y - p0.y - verticalSlope * x) / (baseSlope - verticalSlope);
  var nextY = p0.y - baseSlope * (p0.x - nextX);
  return {
    x: nextX,
    y: nextY
  };
};
/**
 * 根据两点坐标，计算距离
 * @param {Point} p0
 * @param {Point} p1
 */


exports.squareCrossPoint = squareCrossPoint;

var pointsDistance = function pointsDistance(p0, p1) {
  var x = p0.x - p1.x;
  var y = p0.y - p1.y;
  return Math.sqrt(x * x + y * y);
};

exports.pointsDistance = pointsDistance;

var EndPoints =
/*#__PURE__*/
function () {
  function EndPoints(rect) {
    _classCallCheck(this, EndPoints);

    this.rect = rect;
    this._lt = null;
    this._rt = null;
    this._rb = null;
    this._lb = null;
    this._ct = null;
    this._cb = null;
    this._rm = null;
    this._lm = null;
    this._center = null;
  }

  _createClass(EndPoints, [{
    key: "center",
    get: function get() {
      if (!this._center) {
        this._center = rectCenter(this.rect);
      }

      return this._center;
    }
  }, {
    key: "lt",
    get: function get() {
      if (!this._lt) {
        var _this$rect = this.rect,
            x = _this$rect.x,
            y = _this$rect.y,
            rotate = _this$rect.rotate;
        this._lt = rotatePositionRelatively({
          x: x,
          y: y
        }, this.center, rotate);
      }

      return this._lt;
    }
  }, {
    key: "rt",
    get: function get() {
      if (!this._rt) {
        var _this$rect2 = this.rect,
            x = _this$rect2.x,
            y = _this$rect2.y,
            width = _this$rect2.width,
            rotate = _this$rect2.rotate;
        this._rt = rotatePositionRelatively({
          x: x + width,
          y: y
        }, this.center, rotate);
      }

      return this._rt;
    }
  }, {
    key: "rb",
    get: function get() {
      if (!this._rb) {
        this._rb = symmetryPoint(this.lt, this.center);
      }

      return this._rb;
    }
  }, {
    key: "lb",
    get: function get() {
      if (!this._lb) {
        this._lb = symmetryPoint(this.rt, this.center);
      }

      return this._lb;
    }
  }, {
    key: "ct",
    get: function get() {
      if (!this._ct) {
        this._ct = centerPoint(this.lt, this.rt);
      }

      return this._ct;
    }
  }, {
    key: "cb",
    get: function get() {
      if (!this._cb) {
        this._cb = centerPoint(this.rb, this.lb);
      }

      return this._cb;
    }
  }, {
    key: "rm",
    get: function get() {
      if (!this._rm) {
        this._rm = centerPoint(this.rt, this.rb);
      }

      return this._rm;
    }
  }, {
    key: "lm",
    get: function get() {
      if (!this._lm) {
        this._lm = centerPoint(this.lt, this.lb);
      }

      return this._lm;
    }
  }]);

  return EndPoints;
}();
/* -------------------------------------------------------------------------- */

/*                                    move                                    */

/* -------------------------------------------------------------------------- */

/**
 * 移动矩形，返回移动的矩形数据
 * @param {Point} mouseStart
 * @param {Point} mouseEnd
 * @param {Rect} rectStart
 */


exports.EndPoints = EndPoints;

var moveRect = function moveRect(mouseStart, mouseEnd, rectStart) {
  var x = mouseEnd.x - mouseStart.x;
  var y = mouseEnd.y - mouseStart.y;
  return Object.assign(Object.assign({}, rectStart), {
    x: rectStart.x + x,
    y: rectStart.y + y
  });
};
/* -------------------------------------------------------------------------- */

/*                                   rotate                                   */

/* -------------------------------------------------------------------------- */

/**
 * 根据两点坐标，计算其连线的斜率。注意，垂直时斜率是 Infinity
 * @param {Point} p0
 * @param {Point} p1
 */


exports.moveRect = moveRect;

var lineSlope = function lineSlope(p0, p1) {
  return (p1.y - p0.y) / (p1.x - p0.x);
};
/**
 * 传入两个点 p0， p1，返回两点连线的倾斜角度
 * 垂直状态是 0，遵循 DOM 的 rotation 规则，值域范围 [-90, 90]
 * @param {Point} p0
 * @param {Point} p1
 */


exports.lineSlope = lineSlope;

var lineDegrees = function lineDegrees(p0, p1) {
  if (roughlyEqual(p0.x, p1.x)) {
    return 0;
  }

  var slope = lineSlope(p0, p1);
  var degrees = Math.atan(slope) / Math.PI * 180;
  return 90 + degrees;
};
/**
 * 计算鼠标从 start 点拖到到 end 点时的旋转角度
 * @param {Point[]} pinnedPoints
 * @param {Point} start
 * @param {Point} end
 */


exports.lineDegrees = lineDegrees;

var computeRotation = function computeRotation(center, start, end) {
  var shiftStart = {
    x: start.x - center.x,
    y: start.y - center.y
  };
  var shiftEnd = {
    x: end.x - center.x,
    y: end.y - center.y
  };
  var startDegrees = angleDegrees(shiftStart);
  var endDegrees = angleDegrees(shiftEnd);
  return endDegrees - startDegrees;
};
/**
 * 计算鼠标从 mouseStart 点开始按住旋转到 mouseEnd 后返回的矩形，值域为 [-180, 180]
 * @param {Point} mouseStart
 * @param {Point} mouseEnd
 * @param {Rect} rectStart
 */


exports.computeRotation = computeRotation;

var rotateRect = function rotateRect(mouseStart, mouseEnd, rectStart) {
  var center = rectCenter(rectStart); // const shrotcutRotations = [-180, -135, -90, -45, 0, 45, 90, 135, 180]

  var offsetRotation = computeRotation(center, mouseStart, mouseEnd);
  var nextRotation = rectStart.rotate + offsetRotation;

  if (nextRotation >= 180) {
    nextRotation = nextRotation - 360;
  }

  if (nextRotation <= -180) {
    nextRotation = nextRotation + 360;
  }

  return Object.assign(Object.assign({}, rectStart), {
    rotate: nextRotation
  });
};
/* -------------------------------------------------------------------------- */

/*                                   resize                                   */

/* -------------------------------------------------------------------------- */

/**
 * 根据一条边（pinnedPoints 两点确定），和对应的拖拽点（dragPoint），生成一个宽高比固定的矩形
 * @param {Point[]} pinnedPoints 拖拽固定边
 * @param {Point} dragPoint 拖拽点
 * @param {Number} rectRatio 原始矩形的宽高比
 * @param {"width" | "height"} activeExpand 拖拽的属性（width / height）
 */


exports.rotateRect = rotateRect;

var computeRatioedRectWithPinnedLine = function computeRatioedRectWithPinnedLine(pinnedPoints, dragPoint, rectStart, activeExpand) {
  var _pinnedPoints = _slicedToArray(pinnedPoints, 2),
      p0 = _pinnedPoints[0],
      p1 = _pinnedPoints[1];

  var middle1 = centerPoint(p0, p1);
  var middle2 = dragPoint;
  var center = centerPoint(middle1, middle2);
  var distance = pointsDistance(middle1, middle2);
  var rectRatio = rectStart.width / rectStart.height;
  var width, height;

  if (activeExpand === "width") {
    width = distance;
    height = width / rectRatio;
  } else {
    height = distance;
    width = rectRatio * height;
  }

  return {
    x: center.x - width / 2,
    y: center.y - height / 2,
    width: width,
    height: height,
    rotate: rectStart.rotate
  };
};
/**
 * 根据一条线段（由 pinnedPoints 两点确定），拖拽点坐标（dragPoint），以及倾斜角度（angle）返回一个确定的矩形
 * @param {Point[]} pinnedPoints
 * @param {Point} dragPoint
 * @param {Number} angle
 */


exports.computeRatioedRectWithPinnedLine = computeRatioedRectWithPinnedLine;

var computeRectWithPinnedLine = function computeRectWithPinnedLine(pinnedPoints, dragPoint, angle) {
  var _pinnedPoints$map = pinnedPoints.map(function (p) {
    return rotatePosition(p, -angle);
  }),
      _pinnedPoints$map2 = _slicedToArray(_pinnedPoints$map, 2),
      rotateP0 = _pinnedPoints$map2[0],
      rotateP1 = _pinnedPoints$map2[1];

  var rotateDrag = rotatePosition(dragPoint, -angle);
  var w, h, rotatedCenter;

  if (roughlyEqual(rotateP0.y, rotateP1.y)) {
    w = Math.abs(rotateP0.x - rotateP1.x);
    h = Math.abs(rotateDrag.y - rotateP0.y);
    rotatedCenter = {
      x: (rotateP0.x + rotateP1.x) / 2,
      y: (rotateP0.y + rotateDrag.y) / 2
    };
  } else if (roughlyEqual(rotateP0.x, rotateP1.x)) {
    h = Math.abs(rotateP0.y - rotateP1.y);
    w = Math.abs(rotateDrag.x - rotateP0.x);
    rotatedCenter = {
      x: (rotateP0.x + rotateDrag.x) / 2,
      y: (rotateP0.y + rotateP1.y) / 2
    };
  }

  var center = rotatePosition(rotatedCenter, angle);
  var x = center.x - (w || 0) / 2;
  var y = center.y - (h || 0) / 2;
  return {
    x: x,
    y: y,
    width: w,
    height: h,
    rotate: angle
  };
};
/**
 * resize 矩形，返回 resize 后的矩形数据
 * @param {Point} mouseStart
 * @param {Point} mouseEnd
 * @param {AdjustType} adjustType
 * @param {Rect} rectStart
 * @param {number} fixedRatio
 */


exports.computeRectWithPinnedLine = computeRectWithPinnedLine;

var resizeRect = function resizeRect(mouseStart, mouseEnd, adjustType, rectStart, fixedRatio) {
  var e = new EndPoints(rectStart);
  var activeExpand = null;
  var acrossPoints = [];
  var fixedMouseEnd = mouseEnd;

  if (fixedRatio) {
    switch (adjustType) {
      case "nw":
      case "se":
        acrossPoints = [e.lt, e.rb];
        break;

      case "ne":
      case "sw":
        acrossPoints = [e.rt, e.lb];
        break;

      case "n":
      case "s":
        acrossPoints = [e.ct, e.cb];
        activeExpand = "height";
        break;

      case "w":
      case "e":
        acrossPoints = [e.lm, e.rm];
        activeExpand = "width";
        break;

      default:
        acrossPoints = [];
    }

    if (acrossPoints.length === 2) {
      fixedMouseEnd = squareCrossPoint(acrossPoints, mouseEnd);
    }
  }

  var pinnedPoints = [];

  switch (adjustType) {
    case "nw":
      pinnedPoints = [e.rb];
      break;

    case "ne":
      pinnedPoints = [e.lb];
      break;

    case "sw":
      pinnedPoints = [e.rt];
      break;

    case "se":
      pinnedPoints = [e.lt];
      break;

    case "s":
      pinnedPoints = [e.lt, e.rt];
      break;

    case "n":
      pinnedPoints = [e.lb, e.rb];
      break;

    case "w":
      pinnedPoints = [e.rt, e.rb];
      break;

    case "e":
      pinnedPoints = [e.lt, e.lb];
      break;

    default:
      pinnedPoints = [];
  }

  var _pinnedPoints2 = pinnedPoints,
      length = _pinnedPoints2.length;
  var result;

  if (length === 1) {
    result = computeRectWithCrossPoints(pinnedPoints[0], fixedMouseEnd, rectStart.rotate);
  } else if (length === 2) {
    if (fixedRatio) {
      result = computeRatioedRectWithPinnedLine(pinnedPoints, fixedMouseEnd, rectStart, activeExpand);
    } else {
      result = computeRectWithPinnedLine(pinnedPoints, fixedMouseEnd, rectStart.rotate);
    }
  }

  return result;
};
/**
 * 计算入口
 * @param {Position} mouseStart
 * @param {Position} mouseEnd
 * @param {AdjustType} adjustType: 'rotate'|'move'|'lt'|'rt'|'ct'|'lb'|'rb'|'cb'|'lm'|'rm'|null
 * @param {Rect} rectStart: { x: Number, y: Number, width: Number, height: Number, rotate: Number }
 * @param {Boolean} fixedRatio
 */


exports.resizeRect = resizeRect;

var _default = function _default(adjustType, mouseStart, mouseEnd, rectStart) {
  var fixedRatio = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if (adjustType === "move") {
    return moveRect(mouseStart, mouseEnd, rectStart);
  }

  if (adjustType === "rotate") {
    return rotateRect(mouseStart, mouseEnd, rectStart);
  }

  return resizeRect(mouseStart, mouseEnd, adjustType, rectStart, fixedRatio);
};

exports.default = _default;